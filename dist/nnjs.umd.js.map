{"version":3,"file":"nnjs.umd.js","sources":["../src/utils.js","../src/greyscalewindow.js","../src/color.js","../src/edge.js","../src/node.js","../src/neuron.js","../src/subnetwork.js","../src/dtneuron.js","../src/network.js"],"sourcesContent":["/**\n * @param  {Number} a\n * @param  {Number} b\n * @return {Number}\n */\nexport function distance(a, b) {\n  return ((a > b) ? (a - b) : (b - a));\n}\n","import * as utils from './utils';\n\n/**\n * @const\n * @type {Number}\n */\nconst SIZE = 3;\n\n/**\n * Scan window\n *\n * @param {Array.<Array.<Color>>} img\n *\n * @constructor\n */\nexport default class GreyscaleWindow {\n\n  constructor(img) {\n\n    /**\n     * @type {Array.<Array.<Number>>}\n     */\n    this._matrix = GreyscaleWindow.getMatrix(img);\n\n    /**\n     * Upper grey level\n     * @type {Number}\n     */\n    this.ugl = 0;\n\n    /**\n     * Lower grey level\n     * @type {Number}\n     */\n    this.lgl = 0;\n\n    /**\n     * Average grey level\n     * @type {Number}\n     */\n    this.agl = 0;\n\n    if (img.length  === GreyscaleWindow.SIZE &&\n      img[0].length === GreyscaleWindow.SIZE) {\n      this.calculateLevels();\n    }\n  }\n\n  /**\n   * @static\n   */\n  static get SIZE() {\n    return SIZE;\n  }\n\n  /**\n   * @param  {Array.<Array.<Color>>} img\n   * @return {Array.<Array.<Color>>}\n   */\n  getMatrix(img) {\n    let matrix = [];\n    for (let i = 0; i < GreyscaleWindow.SIZE; i++) {\n      let tmp = [];\n      for (let j = 0; j < GreyscaleWindow.SIZE; j++) {\n        tmp.push(Color.toGreyScale(img[i, j]));\n      }\n      matrix.push(tmp);\n    }\n    return matrix;\n  }\n\n  clone() {}\n\n  equals(g) {}\n\n  /**\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {Color}\n   */\n  pixel(x, y) {\n    return this._matrix[x][y];\n  }\n\n  /**\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Color} value\n   */\n  setPixel(x, y, value) {\n    this._matrix[x][y] = value;\n  }\n\n  /**\n   * @return {Number}\n   */\n  get width() {\n    return this._matrix.size();\n  }\n\n  /**\n   * @return {Number}\n   */\n  get height() {\n    return this._matrix[0].length;\n  }\n\n  /**\n   * @return {Number}\n   */\n  get upperGreyLevel() {\n    return this.ugl;\n  }\n\n  /**\n   * @return {Number}\n   */\n  get lowerGreyLevel() {\n    return this.lgl;\n  }\n\n  /**\n   * @return {Number}\n   */\n  get averageGreyLevel() {\n    return this.agl;\n  }\n\n  /**\n   * @return {Array.<Array.<Color>>}\n   */\n  toImage() {\n    let res = [];\n    for (let i = 0; i < GreyscaleWindow.SIZE; i++) {\n      res[i] = [];\n      for (let j = 0; j < GreyscaleWindow.SIZE; j++) {\n        res[i][j] = Color.toRgb(Color.fromHsv(20, 0, this._matrix[i][j]));\n      }\n    }\n    return res;\n  }\n\n  /**\n   * @return {Array.<Array.<Color>>}\n   */\n  toMonochromeImage() {\n    let res = [];\n    for (let i = 0; i < GreyscaleWindow.SIZE; i++) {\n      res[i] = [];\n      for (let j = 0; j < GreyscaleWindow.SIZE; j++) {\n        res[i][j] = Color.fromHsv(20, 0, this._matrix[i][j]);\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Calculates thresholds\n   */\n  calculateLevels() {\n    let sum1 = 0;\n    let sum2 = 0;\n    let upperCount = 0;\n    let lowerCount = 0;\n    let i, j, agl, lgl, ugl;\n\n    for (i = 0; i < GreyscaleWindow.SIZE; i++) {\n      for (j = 0; j < GreyscaleWindow.SIZE; j++) {\n        sum1 += this._matrix[i][j];\n      }\n    }\n\n    agl = sum1 / (GreyscaleWindow.SIZE * GreyscaleWindow.SIZE);\n\n    sum1 = 0;\n\n    for (i = 0; i < GreyscaleWindow.SIZE; i++) {\n      for (j = 0; j < GreyscaleWindow.SIZE; j++) {\n        if (this._matrix[i][j] < agl) {\n          sum2 += this._matrix[i][j];\n          lowerCount++;\n        } else {\n          sum1 += this._matrix[i][j];\n          upperCount++;\n        }\n      }\n    }\n\n    ugl = (upperCount > 0) ? (sum1 / upperCount) : agl;\n    lgl = (lowerCount > 0) ? (sum2 / lowerCount) : agl;\n\n    this.ugl = ugl;\n    this.lgl = lgl;\n    this.agl = agl;\n  }\n\n}\n","export const WHITE = '';\n\nexport const BLACK = '';\n\n/**\n * @param  {Number} color\n * @return {Number}\n */\nexport function toGreyScale(color) {\n  return color;\n}\n","import * as utils from './utils';\nimport {\n  WHITE, BLACK, toGreyScale\n}\nfrom './color';\n\n/**\n * Patch size\n * @const\n * @type {Number}\n */\nconst SIZE = 3;\n\n/**\n * Edge configuration\n *\n * @param {Array} matrix\n * @param {Number} mmax\n * @param {Number} mmin\n *\n * @constructor\n */\nexport default class Edge {\n\n  constructor(matrix, mmax, mmin) {\n\n    /**\n     * @type {Array}\n     */\n    this.edge = [];\n\n    if (arguments.length === 0) {\n      for (let i = 0; i < Edge.SIZE; i++) {\n        let row = [];\n        for (let j = 0, jj = Edge.SIZE; j < jj; j++) {\n          row[j] = WHITE;\n        }\n        this.edge.push(row);\n      }\n    } else {\n\n      if (matrix.length !== Edge.SIZE || matrix[0].length !== Edge.SIZE) {\n        throw new Error('Wrong matrix size');\n      }\n\n      let i, ii, j, jj;\n\n      // copy\n      for (i = 0, ii = matrix.length; i < ii; i++) {\n        this.edge.push(matrix[i].slice());\n      }\n\n      for (i = 0, ii = this.edge.length; i < ii; i++) {\n        for (j = 0, jj = this.edge[i].length; i < ii; i++) {\n          if (utils.distance(this.edge[i][j], mmin) <\n            utils.distance(this.edge[i][j], mmax)) {\n            this.edge[i][j] = BLACK;\n          } else {\n            this.edge[i][j] = WHITE;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @static\n   */\n  static get SIZE() {\n    return SIZE;\n  }\n\n  /**\n   * @param  {Edge} edge\n   * @return {Boolean}\n   */\n  equals(edge) {}\n\n  /**\n   * @return {Edge} [description]\n   */\n  clone() {\n    let copy = new Edge();\n    for (i = 0, ii = matrix.length; i < ii; i++) {\n      copy.edge.push(this.edge[i].slice());\n    }\n    return copy;\n  }\n\n  /**\n   * @return {Array.<Array.<Number>>}\n   */\n  get edgemap() {\n    return this.edge;\n  }\n\n  /**\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Number} value\n   */\n  set(x, y, value) {\n    this.edge[x][y] = value;\n  }\n\n  /**\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {Number}\n   */\n  pixel(x, y) {\n    return this.edge[x][y];\n  }\n\n  /**\n   * Lossy central rotation\n   * @return {Edge}\n   */\n  rotate45() {\n    let copy = this.clone();\n    let edge = this.edge;\n\n    copy.set(0, 0, edge[1][0]);\n    copy.set(0, 1, edge[0][0]);\n    copy.set(0, 2, edge[0][1]);\n    copy.set(1, 2, edge[0][2]);\n    copy.set(2, 2, edge[1][2]);\n    copy.set(2, 1, edge[2][2]);\n    copy.set(2, 0, edge[2][1]);\n    copy.set(1, 0, edge[2][0]);\n    copy.set(1, 1, edge[1][1]);\n\n    return copy;\n  }\n\n  /**\n   * @return {Array.<Array.<Number>}\n   */\n  toImage() {\n    let result = [];\n    for (let i = 0; i < SIZE; i++) {\n      for (let j = 0; j < SIZE; j++) {\n        result[i][j] = this.edge[i][j];\n      }\n    }\n    return result;\n  }\n\n}\n","import Edge from './edge';\nimport * as utils from './utils';\n\n/**\n * @const\n * @type {Edge}\n */\nconst blankEdge = new Edge();\n\n/**\n * @type {Array}\n */\nlet validEdges = [];\n\n/**\n * @type {Number}\n */\nlet trainIteration = 0;\n\n/**\n * @type {Number}\n */\nlet trainIterations = 0;\n\n\nexport default class Node {\n\n  constructor() {}\n\n  /**\n   * @const\n   * @type {Edge}\n   */\n  static get blankEdge() {\n    return blankEdge;\n  }\n\n  /**\n   * @const\n   * @type {Array.<Edge>}\n   */\n  static get validEdges() {\n    return validEdges;\n  }\n\n  /**\n   * @static\n   * @type {Number}\n   */\n  static get trainIteration() {\n    return trainIteration;\n  }\n\n  static set trainIteration(i) {\n    trainIteration = i;\n  }\n\n  /**\n   * @static\n   * @type {Number}\n   */\n  static get trainIterations() {\n    return trainIterations;\n  }\n  static set trainIterations(i) {\n    trainIterations = i;\n  }\n\n  /**\n   * @param {Edge} edge\n   * @return {Boolean}\n   */\n  isValid(edge) {\n    for (let i = 0, len = Node.validEdges.length; i < len; i++) {\n      if (edge.equals(Node.validEdges[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param  {Edge} edge\n   * @return {Edge}\n   */\n  validate(edge) {\n    let i, len;\n    // training is in process\n    if (Node.totalTrainIterations !== 0) {\n      // the edge is not in set, add it\n      if (!this.isValid(edge)) {\n        Node.validEdges.push(edge);\n      }\n\n      // variations:\n      // rotate 45 7 times and put into valid edges set\n      let tmp = edge.rotate45();\n      let rotations = 6;\n\n      for (i = 0; i < rotations; i++) {\n        if (!this.isValid(tmp)) {\n          Node.validEdges.push(tmp);\n        }\n        tmp = tmp.rotate45();\n      }\n    }\n\n    // return valid edge from the set\n    for (i = 0, len = Node.validEdges.length; i < len; i++) {\n      if (edge.equals(Node.validEdges[i])) {\n        return Node.validEdges[i];\n      }\n    }\n\n    // if not present in set, which could occur\n    // during the search, return blank\n    return Node.BlankEdge;\n  }\n\n  /**\n   * @param  {Number} i\n   * @param  {Number} tf\n   * @return {Number}\n   */\n  eta(i, tf) {\n    if (Node.totalTrainIterations != 0) {\n      return (this.eta(0, Node.totalTrainIterations) *\n        (1 - Node.trainIteration / Node.totalTrainIterations));\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * @return {Number}\n   */\n  memorySize() {\n    return Node.validEdges.length;\n  }\n\n  /**\n   * @param  {Number} num\n   * @return {Edge}\n   */\n  getPrototype(num) {\n    return (num < Node.validEdges.size()) ?\n      Node.validEdges[num] :\n      Node.blankEdge;\n  }\n};\n","import Node from './node';\nimport * as utils from './utils';\nimport GreyscaleWindow from './greyscalewindow';\nimport Edge from './edge';\n\n/**\n * Neuron\n * @param {Number} w1 Threshold\n * @param {Number} w2 Threshold\n *\n * @constructor\n * @extends {Node}\n */\nexport default class Neuron extends Node {\n\n  constructor(w1, w2) {\n    super();\n\n    /**\n     * @type {Number}\n     */\n    this.max = 0;\n\n    /**\n     * @type {Number}\n     */\n    this.min = 0;\n\n    if (w1 > w2) {\n      this.max = w1;\n      this.min = w2;\n    } else {\n      this.max = w2;\n      this.min = w1;\n    }\n\n    this.edgeMap = null;\n  }\n\n  /**\n   * @param  {GreyscaleWindow} win\n   * @return {Edge}\n   */\n  detect(win) {\n    this.min += (this.eta() * (win.lowerGreyLevel() - this.min));\n    this.max += (this.eta() * (win.upperGreyLevel() - this.max));\n    Node.trainIteration++;\n    return this.toMap(win);\n  }\n\n  /**\n   * @return {Number}\n   */\n  upperThreshold() {\n    return this.max;\n  }\n\n  /**\n   * @return {Number}\n   */\n  lowerThreshold() {\n    return this.min;\n  }\n\n  /**\n   * @param  {GreyscaleWindow} imgWindow\n   * @return {Edge}\n   */\n  toMap(imgWindow) {\n    return new Edge(imgWindow.matrix(), this.wmin, this.wmax);\n  }\n};\n","import Neuron from './neuron';\nimport Node from './node';\nimport GreyscaleWindow from './greyscalewindow';\n\n/**\n * Subnetwork\n *\n * @constructor\n * @extends {Node}\n */\nexport default class Subnetwork extends Node {\n\n  /**\n   * @param {Number} illuminationLevelPrototype\n   * @param {Number} neuron1UpperThreshold\n   * @param {Number} neuron1LowerThreshold\n   * @param {Number} neuron2UpperThreshold\n   * @param {Number} neuron2LowerThreshold\n   */\n  constructor(illuminationLevelPrototype,\n    neuron1UpperThreshold, neuron1LowerThreshold,\n    neuron2UpperThreshold, neuron2LowerThreshold) {\n\n    super();\n\n    /**\n     * @type {Neuron}\n     */\n    this.strong = null;\n\n    /**\n     * @type {Neuron}\n     */\n    this.weak = null;\n\n    /**\n     * Selected illumination prototype\n     * @type {Number}\n     */\n    this.pr = null;\n\n    if (utils.distance(neuron1UpperThreshold, neuron1LowerThreshold) >\n        utils.distance(neuron2UpperThreshold, neuron2LowerThreshold)) {\n      this.strong = new Neuron(neuron1UpperThreshold, neuron1LowerThreshold);\n      this.weak   = new Neuron(neuron2UpperThreshold, neuron2LowerThreshold);\n    } else {\n      this.strong = new Neuron(neuron2UpperThreshold, neuron2LowerThreshold);\n      this.weak   = new Neuron(neuron1UpperThreshold, neuron1LowerThreshold);\n    }\n  }\n\n  /**\n   * @param  {Subnetwork} s\n   * @return {Boolean}\n   */\n  equals(s) {\n    return this.pr === s.pr &&\n      this.weak.equals(s.weakNeuron()) &&\n      this.strong.equals(s.strongNeuron());\n  }\n\n  /**\n   * @param  {GreyscaleWindow} win\n   * @return {Neuron}\n   */\n  neuronCompetition(win) {\n    const { sqrt } = Math;\n    const { strong, weak } = this;\n    const upper   = img.upperGreyLevel();\n    const lower   = img.lowerGreyLevel();\n    const dWUpper = upper - weak.upperThreshold();\n    const dWLower = lower - weak.lowerThreshold();\n    const dSUpper = upper - strong.upperThreshold();\n    const dSLower = lower - strong.lowerThreshold();\n\n    if (sqrt(dWUpper * dWUpper + dWLower * dWLower) <\n        sqrt(dSUpper * dSUpper + dSLower * dSLower)) {\n      return weak;\n    } else {\n      return strong;\n    }\n  }\n\n  /**\n   * @param  {GreyscaleWindow} win\n   * @return {Edge}\n   */\n  detect(win) {\n    this.pr += (this.eta() * (win.averageGreyLevel() - this.pr));\n\n    var winner = this.neuronCompetition(win),\n      // otherwise the weak neuron won't learn\n      detectionResult = winner.detect(win);\n\n    if (this.a2(win.upperGreyLevel(), win.lowerGreyLevel())) {\n      if (this.a3(detectionResult)) {\n        return validate(detectionResult);\n      } else {\n        return Node.blankEdge;\n      }\n    } else {\n      return Node.blankEdge;\n    }\n  }\n\n  /**\n   * @return {Number}\n   */\n  illuminationPrototype() {\n    return this.pr;\n  }\n\n  /**\n   * @return {Neuron}\n   */\n  weakNeuron() {\n    return this.weak;\n  }\n\n  /**\n   * @return {Neuron}\n   */\n  strongNeuron() {\n    return this.strong;\n  }\n\n  /**\n   * This rule doesn't work during the learning, since it get applied when\n   * the weights of the neurons could already have been changed.\n   * If we put this before neurons weight correction, weak neuron won't learn\n   *\n   * @param  {Number} mmax\n   * @param  {Number} mmin\n   * @return {Boolean}\n   */\n  a2(mmax, mmin) {\n    return (mmax - mmin) >=\n      (this.weak.upperThreshold() - this.weak.lowerThreshold());\n  }\n\n  /**\n   * @param {Edge}\n   * @return {Boolean}\n   */\n  a3(edge) {\n    return !this.validate(edge).equals(Node.blankEdge);\n  }\n};\n","import GreyscaleWindow from './greyscalewindow';\nimport Node from './node';\nimport Edge from './edge';\n\n/**\n * @param {GreyscaleWindow} img\n *\n * @constructor\n * @extends {Node}\n */\nexport default class DTNeuron extends Node {\n\n  constructor(img) {\n    super();\n\n    /**\n     * @type {Number}\n     */\n    this.illuminationLevel = img.averageGreyLevel();\n\n    /**\n     * @type {Number}\n     */\n    this.upperThreshold = img.upperGreyLevel();\n\n    /**\n     * @type {Number}\n     */\n    this.lowerThreshold = img.lowerGreyLevel();\n  }\n\n\n  /**\n   * @param  {Array.<GreyscaleWindow>} env\n   * @return {Array.<Edge>}\n   */\n  detect(env) {\n    let edges = [];\n    for (let i = 0, len = env.length; i < len; i++) {\n      let tmp = new Edge(env[i].matrix(), this.upperThreshold, this.lowerThreshold);\n      if (this.b1(tmp) && this.b2(env[i].upperGreyLevel(), env[i].lowerGreyLevel())) {\n        this.updateIlluminationLevel(env[i].averageGreyLevel(), i, len);\n        if (this.a2(env[i].upperGreyLevel(), env[i].lowerGreyLevel(), upperThreshold, lowerThreshold)) {\n          this.updateThresholds(env[i].upperGreyLevel(), env[i].lowerGreyLevel(), i, len);\n        }\n        edges.push(tmp);\n      } else {\n        edges.push(Node.blankEdge);\n      }\n    }\n    return edges;\n  };\n\n  /**\n   * @param  {Edge} edge\n   * @return {Boolean}\n   */\n  b1(edge) {\n    return !this.validate(edge).equals(Node.blankEdge);\n  }\n\n  /**\n   * @param  {Number} mmax\n   * @param  {Number} mmin\n   * @return {Boolean}\n   */\n  b2(mmax, mmin) {\n    return (this.illuminationLevel <= mmax) && (this.illuminationLevel >= mmin);\n  }\n\n  /**\n   * @param  {Number} mmax\n   * @param  {Number} mmin\n   * @param  {Number} wmax\n   * @param  {Number} wmin\n   * @return {Boolean}\n   */\n  a2(mmax, mmin, wmax, wmin) {\n    return (mmax - mmin) >= (wmax - wmin);\n  }\n\n  /**\n   * @param  {Number} ms\n   * @param  {Number} i\n   * @param  {Number} tf\n   */\n  updateIlluminationLevel(ms, i, tf) {\n    this.illuminationLevel += (ms - this.illuminationLevel) * this.eta(i, tf);\n  }\n\n  /**\n   * @param  {Number} mmax\n   * @param  {Number} mmin\n   * @param  {Number} i\n   * @param  {Number} tf\n   */\n  updateThresholds(mmax, mmin, i, tf) {\n    this.upperThreshold += (this.upperThreshold - mmax) * this.eta(i, tf);\n    this.lowerThreshold += (this.lowerThreshold - mmin) * this.eta(i, tf);\n  }\n}\n","import GreyscaleWindow from './greyscalewindow';\nimport Node            from './node';\nimport Subnetwork      from './subnetwork';\nimport Neuron          from './neuron';\nimport DTNeuron        from './dtneuron';\nimport * as utils      from './utils';\n\n\n/**\n * @constructor\n * @extends {Node}\n */\nexport default class Network extends Node {\n\n  /**\n   * @param {Number} N subnetworks count\n   */\n  constructor(N) {\n    super();\n    let tmp = 0;\n    let gradientWidth = 256;\n    let divider  = 4;\n    let quantity = N;\n\n    const bits = gradientWidth / (N * divider);\n\n    /**\n     * @type {Array.<Subnetwork>}\n     */\n    this.subnetworks = [];\n\n    for (let i = 0; i < N; i++) {\n      let n1lower = tmp;\n      let n2lower = tmp + bits;\n      let illuminationPrototype = tmp + bits * 2;\n      let n2upper = tmp + bits * 3;\n      let n1upper = tmp + bits * 4;\n\n      tmp = n1upper;\n      subnetworks.push(\n        new Subnetwork(illuminationPrototype,\n          n1upper, n1lower, n2upper, n2lower));\n    }\n\n    /**\n     * @type {Number}\n     */\n    this.widthIncrement = 0;\n\n    /**\n     * @type {Number}\n     */\n    this.heightIncrement = 0;\n\n    /**\n     * @type {Object}\n     */\n    this.resizedImageSize = null;\n\n    this.edgeTableRows = null;\n\n    this.edgeTableCols = null;\n\n    this.dynamicNeuron = null;\n\n    this.subnetworks = [];\n\n    this.edgeMaps = [];\n\n    this.greyscaleWindows = [];\n\n    this.primaryEdgePoints = [];\n\n  }\n\n  /**\n   * @param  {GreyscaleWindow} win\n   * @return {Subnetwork}\n   */\n  subnetworkCompetition(win) {\n    let dist = 256;\n    let lgl = win.lowerGreyLevel();\n    let ugl = win.upperGreyLevel();\n    let agl = win.averageGreyLevel();\n    let tempDist, subnetwork, res, illuminationPrototype;\n\n    for (let i = 0, len = this.subnetworks.length; i < len; i++) {\n      illuminationPrototype = this.subnetworks[i].illuminationPrototype();\n      if (illuminationPrototype >= lgl &&\n        illuminationPrototype <= ugl) {\n\n        tempDist = utils.distance(illuminationPrototype, agl);\n        if (tempDist < dist) {\n          dist = tempDist;\n          res = subnetworks[i];\n        }\n      }\n    }\n\n    return res;\n  }\n\n  /**\n   * @param  {GreyscaleWindow} img\n   * @return {GreyscaleWindow}\n   */\n  detect(img) {\n    // resize to fit the grid\n    let resizedImage = this.resize(img);\n    const N = GreyscaleWindow.SIZE;\n\n    this.resizedImageSize = {\n      x: resizedImage.width(),\n      y: resizedImage.height()\n    };\n\n    this.edgeTableRows = resizedImageSize.height() / N;\n    this.edgeTableCols = resizedImageSize.width() / N;\n\n    // primary edge points by subnetworks\n    this.detectPrimaryEdgePoints(resizedImage);\n    // secondary - by dynamic neuron\n    this.detectSecondaryEdgePoints();\n    this.drawEdges(resizedImage);\n\n    this.resizedImage = crop(resizedImage);\n\n    // free mem\n    this.edgeMaps = null;\n    this.greyscaleWindows = null;\n    this.primaryEdgePoints = null;\n\n    // return monochrome\n    return resizedImage;\n  }\n\n  /**\n   *\n   * @param  {Array.<GreyscaleImage>} imgs\n   * @return {Array.<GreyscaleImage>}\n   */\n  train(imgs) {\n    let res = [];\n    const N = GreyscaleWindow.SIZE;\n\n    // learning\n    for (let i = 0, len = imgs.length; i < len; i++) {\n      // Count all learining iterations.  It consists of all patches of\n      // all images in the training set. Otherwise learining process would\n      // flush the result of the previous iteration. The result depend not\n      // only on the learning set contents but on the order of images in it\n      // as well\n      let tmpw = 0;\n      let tmph = 0;\n      let img = imgs[i];\n      let [w, h] = [img.width(), img.height()];\n\n      while ((tmpw * N) < w) {\n        tmpw++;\n      }\n      while ((tmph * N) < h) {\n        tmph++;\n      }\n      Node.totalTrainIterations += (tmpw * tmph);\n    }\n    Node.trainIteration = 0;\n\n    for (var i = 0; i < imgs.length; i++) {\n      res.push(this.detect(imgs[i]));\n    }\n    Node.totalTrainIterations = 0;\n    return res;\n  }\n\n  /**\n   * @return {Number}\n   */\n  get subnetworksCount() {\n    return this.subnetworks.length;\n  }\n\n  /**\n   * @param  {GreyscaleWindow} img\n   * @return {GreyscaleWindow}\n   */\n  resize(img) {\n    this.widthIncrement = 0;\n    this.heightIncrement = 0;\n\n    let i, j;\n    const N = GreyscaleWindow.SIZE;\n    let matrix = img.matrix();\n\n    while (((matrix.length + this.heightIncrement) % N) != 0) {\n      this.heightIncrement++;\n    }\n\n    while (((matrix[0].length + this.widthIncrement) % N) != 0) {\n      this.widthIncrement++;\n    }\n\n    let data = img.matrix();\n    for (i = 0; i < data.length; i++) {\n      for (j = 0; j < this.widthIncrement; j++) {\n        data[i].push(WHITE);\n      }\n    }\n\n    for (i = 0; i < heightIncrement; i++) {\n      let tmp = [];\n      for (j = 0; j < N + this.widthIncrement; j++) {\n        tmp.push(Color.BLACK);\n      }\n      data.push(tmp);\n    }\n    return new GreyscaleWindow(data);\n  }\n\n  /**\n   * @param  {GreyscaleWindow} img\n   * @return {GreyscaleWindow}\n   */\n  crop(img) {\n    let data = img.matrix();\n    while (this.heightIncrement--) {\n      data.pop();\n    }\n\n    for (let i = 0, len = data.length; i < len; i++) {\n      data[i] = data[i].slice(0, data[i].length - this.widthIncrement);\n    }\n    this.widthIncrement = 0;\n    return data;\n  }\n\n  /**\n   * @param  {GreyscaleWindow} img\n   */\n  detectPrimaryEdgePoints(img) {\n    const N = GreyscaleWindow.SIZE;\n    let i, ii, j, jj, k;\n\n    // illumination matrix rows\n    for (i = 0, ii = img.height(); i < ii; i += N) {\n\n      // illumination matrix cols\n      for (j = 0, jj = img.width(); j < jj; j += N) {\n        let data = [];\n        // get image patches\n        for (k = 0; k < N; k++) {\n          data.push(img._matrix[i + k].slice(j, N));\n        }\n\n        // to greyscale windows\n        let currentWindow = new GreyscaleWindow(data);\n        // store\n        this.greyscaleWindows.push(currentWindow);\n\n        // subnetworks compete for the patch\n        let winner = this.subnetworkCompetition(currentWindow);\n\n        // get a primary edge point, extracted by the winner\n        if (winner) {\n          this.edgeMaps.push(winner.detect(currentWindow));\n        } else {\n          Node.trainIteration++;\n          this.edgeMaps.push(new Edge());\n        }\n      }\n    }\n  }\n\n  /**\n   * Detects secondary options\n   */\n  detectSecondaryEdgePoints() {\n    let [x, y] = [0, 0];\n    const N = GreyscaleWindow.SIZE;\n\n    for (let i = 0, len = this.edgeMaps.length; i < len; i++) {\n      if (x == (this.resizedImageSize.width() / N)) {\n        x = 0;\n        y++;\n      }\n\n      // primary edge found\n      if (!this.edgeMaps[i].equals(Node.blankEdge)) {\n        // environment stack: get existing env patches coords\n        let env = this.getPrimaryPointEnvironment(i);\n        // init a dynamic neuron from primary patch\n        this.dynamicNeuron = new DTNeuron(this.greyscaleWindows[i]);\n        // store the results of dynamic neuron detection\n        this.setPrimaryPointEnvironment(i, dynamicNeuron.detect(env));\n\n        this.dynamicNeuron = null;\n      }\n      x++;\n    }\n  }\n\n  /**\n   * @param  {Number} number\n   * @return {Array.<GreyscaleWindow}\n   */\n  getPrimaryPointEnvironment(number) {\n    let env = [];\n    let numbers = [-1, -1, -1, -1, -1, -1, -1, -1];\n\n    // get surrounding coords\n    numbers = this.setEnvironmentPointsNumbers(number, numbers);\n    for (var i = 0, len = numbers.length; i < len; i++) {\n      // exists\n      if ((numbers[i] !== -1)) {\n        env.push(this.greyscaleWindows[numbers[i]]);\n      }\n    }\n    return env;\n  }\n\n  /**\n   * @param {Number} number\n   * @param {Array.<Edge>} env\n   */\n  setPrimaryPointEnvironment(number, env) {\n    let numbers = [-1, -1, -1, -1, -1, -1, -1, -1];\n    let i = 0;\n\n    // get env coords\n    numbers = setEnvironmentPointsNumbers(number, numbers);\n    for (let j = 0, len = numbers.length; j < len; j++) {\n      // it's already has been here\n      if (numbers[j] !== -1) {\n        // get edge map for it and store into the global\n        if (this.edgeMaps[numbers[j]].equals(Node.blankEdge)) {\n          this.edgeMaps[numbers[j]] = env[i];\n        }\n        i++;\n      }\n    }\n  };\n\n  /**\n   * 1 2 3\n   * 0 x 4\n   * 7 6 5\n   * Patch coord\n   *\n   * @param {Number} number\n   * @param {Array.<Number>} numbers\n   * @return {Array.<Number>} numbers\n   */\n  setEnvironmentPointsNumbers(number, nums) {\n    let col = number;\n    let row = 0;\n\n    while (col > (this.edgeTableCols - 1)) {\n      col -= this.edgeTableCols;\n      row++;\n    }\n\n    // by default - no patches in env\n\n    // left neighbour\n    if (col > 0) {\n      nums[0] = number - 1;\n\n      // left above\n      if (row > 0) {\n        nums[1] = (number - 1 - this.edgeTableCols);\n      }\n\n      // left below\n      if (row < (this.edgeTableRows - 1)) {\n        nums[7] = (number - 1 + this.edgeTableCols);\n      }\n    }\n\n    // right neighbours\n    if (col < (this.edgeTableCols - 1)) {\n      nums[4] = number + 1;\n      // right above\n      if (row > 0) {\n        nums[3] = (number + 1 - edgeTableCols);\n      }\n\n      // right below\n      if (row < (edgeTableRows - 1)) {\n        nums[5] = (number + 1 + edgeTableCols);\n      }\n    }\n\n    // below\n    if (row < (this.edgeTableRows - 1)) {\n      nums[6] = number + this.edgeTableCols;\n    }\n    // above\n    if (row > 0) {\n      nums[2] = number - this.edgeTableCols;\n    }\n\n    return nums;\n  };\n\n  /**\n   * @param  {GreyscaleWindow} img\n   */\n  drawEdges(img) {\n    let [row, col] = [0, 0];\n    const N = GreyscaleWindow.SIZE;\n\n    while (row < this.edgeTableRows) {\n      while (col < this.edgeTableCols) {\n        for (let i = 0; i < N; i++) {\n          for (let j = 0; j < N; j++) {\n            img.setPixel(row * N + i,\n              col * N + j,\n              edgeMaps[row * edgeTableCols + col].pixel(i, j)\n            );\n          }\n        }\n        col++;\n      }\n      col = 0;\n      row++;\n    }\n  }\n};\n"],"names":["const","let","this","WHITE","SIZE","Edge","i","j","jj","utils.distance","staticAccessors","prototypeAccessors","super","Node","Network"],"mappings":"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"}